package Class::Meta;

# $Id: Meta.pm,v 1.27 2003/11/25 00:58:17 david Exp $

=head1 NAME

Class::Meta - Class automation, introspection, and data validation

=head1 SYNOPSIS

  package MyApp::Thingy;
  use Class::Meta;
  use strict;
  use warnings;

  BEGIN {
      # Create a Class::Meta object for this class.
      my $c = Class::Meta->new('thingy');

      # Add a constructor.
      $c->add_ctor( name => 'new',
                    create  => 1 );

      # Add a couple of attributes with generated methods.
      $c->add_attr( name     => 'id',
                    view     => Class::Meta::PUBLIC,
                    authz    => Class::Meta::READ,
                    create   => Class::Meta::GET,
                    type     => 'integer',
                    label    => 'ID',
                    desc     => "The person object's ID.",
                    required => 1,
                    default  => sub { ... }
                  );
      $c->add_attr( name     => 'name',
                    view     => Class::Meta::PUBLIC,
                    authz    => Class::Meta::RDWR,
                    create   => Class::Meta::GETSET,
                    type     => 'string',
                    len      => 256,
                    label    => 'Name',
                    field    => 'text',
                    desc     => "The person's name.",
                    required => 1,
                    default  => undef,
                  );
      $c->add_attr( name     => 'age',
                    view     => Class::Meta::PUBLIC,
                    authz    => Class::Meta::RDWR,
                    create   => Class::Meta::GETSET,
                    type     => 'inteter',
                    label    => 'Age',
                    field    => 'text',
                    desc     => "The person's age.",
                    required => 0,
                    default  => undef,
                  );

      # Add a custom method.
      $c->add_meth( name  => 'chk_pass',
                    view   => Class::Meta::PUBLIC,
                  );
      $c->build;
  }


=head1 DESCRIPTION

This module implements yet another class automation and parameter validation
interface. Yeah, yeah, there are too many on CPAN alraedy, I know, but of
course, none of them could do exactly what I needed.

And what I needed was an implementation of the "facade" pattern. Okay, this
insn't a facade like the GOF meant it, but it is in the respect that it
creates classes with a common API so that objects of these classes can all be
used identically, calling the same methods on each. This is done via the
implementation of an introspection API.



=cut

##############################################################################
# Dependencies                                                               #
##############################################################################
use 5.008;
use strict;
use warnings;
use Carp ();

##############################################################################
# Constants                                                                  #
##############################################################################

# View. These determine who can get metadata objects back from method calls.
use constant PRIVATE   => 0x01;
use constant PROTECTED => 0x02;
use constant PUBLIC    => 0x03;

# Authorization. These determine what kind of accessors (get, set, both, or
# none) are available for a given attribute or method.
use constant NONE      => 0x01;
use constant READ      => 0x02;
use constant WRITE     => 0x03;
use constant RDWR      => READ | WRITE;

# Method generation. These tell Class::Meta which accessors to create. Use
# NONE above for NONE. These will use the values in the authz argument by
# default. They're separate because sometimes an accessor needs to be built
# by hand, rather than custom-generated by Class::Meta, and the
# authorization needs to reflect that.
use constant GET       => READ;
use constant SET       => WRITE;
use constant GETSET    => RDWR;

# Method and attribute context.
use constant CLASS     => 0x01;
use constant OBJECT    => 0x02;

##############################################################################
# Dependencies that rely on the above constants                              #
##############################################################################
use Class::Meta::Type;
use Class::Meta::Class;
use Class::Meta::Constructor;
use Class::Meta::Attribute;
use Class::Meta::Method;

##############################################################################
# Package Globals                                                            #
##############################################################################
our $VERSION = "0.01";

##############################################################################
# Constructors                                                               #
##############################################################################
{
    my %classes;

    sub new {
        my $pkg = shift;

        # Make sure we can get all the arguments.
        Carp::croak("Odd number of parameters in call to new() when named "
                    . "parameters were expected" ) if @_ % 2;
        my %p = @_;

        # Class defaults to caller. Key defaults to class.
        $p{package} = $p{class} ||= caller;
        $p{key} ||= $p{class};

        # Make sure we haven't been here before.
        Carp::croak("Class '$p{class}' already created")
          if exists $classes{$p{class}};

        # Instantiate a Class object.
        $p{class} = Class::Meta::Class->new(\%p);

        # Cache the definition.
        $classes{$p{package}} = \%p;

        # Return!
        return bless { package => $p{package} }, ref $pkg || $pkg;
    }


##############################################################################
# Instance Methods                                                           #
##############################################################################
# Simple accessors.
    sub my_class { $classes{ $_[0]->{package} }->{class} }

##############################################################################
# add_attr()

    sub add_attr {
        my $spec = $classes{ shift->{package} };
        push @{$spec->{build_attr_ord}},
          Class::Meta::Attribute->new($spec, @_);
        return $spec->{build_attr_ord}[-1];
    }

##############################################################################
# add_meth()

    sub add_meth {
        Class::Meta::Method->new($classes{ shift->{package} }, @_);
    }

##############################################################################
# add_ctor()

    sub add_ctor {
        my $spec = $classes{ shift->{package} };
        push @{$spec->{build_ctor_ord}},
          Class::Meta::Constructor->new($spec, @_);
        return $spec->{build_ctor_ord}[-1];
    }

##############################################################################
# build()
    sub build {
        my $self = shift;
        my $spec = $classes{ $self->{package} };

        # Build the attribute accessors and constructors.
        if (my $objs = $spec->{build_attr_ord}) {
            $_->build($spec) for @$objs;
        }

        if (my $objs = $spec->{build_ctor_ord}) {
            $_->build(\%classes) for @$objs;
        }

        # Build the Class::Meta::Class accessor and my_key shortcut.
        no strict 'refs';
        *{"$spec->{package}::my_class"} = sub { $spec->{class} };
        *{"$spec->{package}::my_key"} = sub { $spec->{key} };

        $spec->{class}->build;
        return $self;
    }
}

1;
__END__

=head1 TO DO

=over 4

=item *

Make it possible to subclass all of the member classes, as well as
Class::Meta::Class, of course.

=item *

Add localization using Locale::Maketext.

=item *

Create unified method for handling exceptions using exception objects. Allow
exceptions to somehow chain, so that all the exceptions for a given
transaction can be recorded. This will allow B<all> of the errors of data
validation for a given object to be recorded at once and show to the user at
once, so that they don't have to fix their problems piecemeal. No, this is not
a simple task. The problem is better described by Perrin here:

  http://mathforum.org/epigone/modperl/pahphucree/3D00F55C.5010103@elem.com

=back

=head1 AUTHOR

David Wheeler <david@wheeler.net>

=head1 SEE ALSO

L<Class::Contract|Class::Contract>

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2002-2003, David Wheeler. All Rights Reserved.

This module is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut
