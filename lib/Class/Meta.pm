package Class::Meta;

# $Id: Meta.pm,v 1.18 2003/11/21 21:21:07 david Exp $

=head1 NAME

Class::Meta - Class automation, introspection, and data validation

=head1 SYNOPSIS

  package MyApp::Thingy;
  use Class::Meta;
  use strict;
  use warnings;

  BEGIN {
      # Create a Class::Meta object for this class.
      my $c = Class::Meta->new('thingy');

      # Add a constructor.
      $c->add_ctor( name => 'new',
                    create  => 1 );

      # Add a couple of attributes with generated methods.
      $c->add_attr( name     => 'id',
                    view     => Class::Meta::PUBLIC,
                    authz    => Class::Meta::READ,
                    create   => Class::Meta::GET,
                    type     => 'integer',
                    label    => 'ID',
                    desc     => "The person object's ID.",
                    required => 1,
                    default  => sub { ... }
                  );
      $c->add_attr( name     => 'name',
                    view     => Class::Meta::PUBLIC,
                    authz    => Class::Meta::RDWR,
                    create   => Class::Meta::GETSET,
                    type     => 'string',
                    len      => 256,
                    label    => 'Name',
                    field    => 'text',
                    desc     => "The person's name.",
                    required => 1,
                    default  => undef,
                  );
      $c->add_attr( name     => 'age',
                    view     => Class::Meta::PUBLIC,
                    authz    => Class::Meta::RDWR,
                    create   => Class::Meta::GETSET,
                    type     => 'inteter',
                    label    => 'Age',
                    field    => 'text',
                    desc     => "The person's age.",
                    required => 0,
                    default  => undef,
                  );

      # Add a custom method.
      $c->add_meth( name  => 'chk_pass',
                    view   => Class::Meta::PUBLIC,
                  );
      $c->build;
  }


=head1 DESCRIPTION

This module implements yet another class automation and parameter validation
interface. Yeah, yeah, there are too many on CPAN alraedy, I know, but of
course, none of them could do exactly what I needed.

And what I needed was an implementation of the "facade" pattern. Okay, this
insn't a facade like the GOF meant it, but it is in the respect that it
creates classes with a common API so that objects of these classes can all be
used identically, calling the same methods on each. This is done via the
implementation of an introspection API.



=cut

##############################################################################
# Dependencies                                                               #
##############################################################################
use 5.008;
use strict;
use warnings;
use Carp ();
use Class::ISA ();

##############################################################################
# Constants                                                                  #
##############################################################################

# View. These determine who can get metadata objects back from method calls.
use constant PRIVATE   => 0x01;
use constant PROTECTED => 0x02;
use constant PUBLIC    => 0x03;

# Authorization. These determine what kind of accessors (get, set, both, or
# none) are available for a given attribute or method.
use constant NONE      => 0x01;
use constant READ      => 0x02;
use constant WRITE     => 0x03;
use constant RDWR      => READ | WRITE;

# Method generation. These tell Class::Meta which accessors to create. Use
# NONE above for NONE. These will use the values in the authz argument by
# default. They're separate because sometimes an accessor needs to be built
# by hand, rather than custom-generated by Class::Meta, and the
# authorization needs to reflect that.
use constant GET       => READ;
use constant SET       => WRITE;
use constant GETSET    => RDWR;

# Method and attribute context.
use constant CLASS     => 0x01;
use constant OBJECT    => 0x02;

# Metadata types. Used internally for tracking the different types of
# Class::Meta objects.
use constant ATTR      => 'attr';
use constant METH      => 'meth';
use constant CTOR      => 'ctor';

##############################################################################
# Dependencies that rely on the above constants                              #
##############################################################################
use Class::Meta::Type;
use Class::Meta::Class;
use Class::Meta::Attribute;
use Class::Meta::Method;
use Class::Meta::Constructor;

##############################################################################
# Package Globals                                                            #
##############################################################################
use vars qw($VERSION);
$VERSION = "0.01";

##############################################################################
# Function and Closure Prototypes                                            #
##############################################################################
my $add_memb;

##############################################################################
# Constructors                                                               #
##############################################################################
{
    my %classes;

    sub new {
        my $pkg = shift;

        # Make sure we can get all the arguments.
        Carp::croak("Odd number of parameters in call to new() when named "
                    . "parameters were expected" ) if @_ % 2;
        my %p = @_;

        # Class defaults to caller. Key defaults to class.
        $p{package} = $p{class} ||= caller;
        $p{key} ||= $p{class};

        # Make sure we haven't been here before.
        Carp::croak("Class '$p{class}' already created")
          if exists $classes{$p{class}};

        # Record the class' inheritance.
        $p{isa} = { Class::ISA::self_and_super_versions($p{class}) };
        $p{isa_ord} = [ Class::ISA::self_and_super_path($p{class}) ];

        # Instantiate a Class object.
        $p{class} = Class::Meta::Class->new(\%p);

        # Cache the definition.
        $classes{$p{package}} = \%p;

        # Return!
        return bless { package => $p{package} }, ref $pkg || $pkg;
    }


##############################################################################
# Instance Methods                                                           #
##############################################################################
# Simple accessors.
    sub my_class { $classes{ $_[0]->{package} }->{class} }

##############################################################################
# add_attr()

    sub add_attr {
        my $spec = $classes{ shift->{package} };
        push @{$spec->{build_attr_ord}},
          Class::Meta::Attribute->new($spec, @_);
        return $spec->{build_attr_ord}[-1];
    }

##############################################################################
# add_meth()

    sub add_meth {
        my $spec = $classes{ shift->{package} };
        push @{$spec->{build_meth_ord}},
          Class::Meta::Method->new($spec, @_);
        return $spec->{build_meth_ord}[-1];
    }

##############################################################################
# add_ctor()

    sub add_ctor {
        my $spec = $classes{ shift->{package} };
        push @{$spec->{build_ctor_ord}},
          Class::Meta::Constructor->new($spec, @_);
        return $spec->{build_ctor_ord}[-1];
    }

##############################################################################
# build()
    sub build {
        my $self = shift;
        my $spec = $classes{ $self->{package} };

        # Build the attribute accessors.
        if (my $ctors = $spec->{build_attr_ord}) {
            $_->build($spec) for @$ctors;
        }

        # Build the constructors.
        if (my $ctors = $spec->{build_ctor_ord}) {
            $_->build($spec) for @$ctors;
        }

        # Build the Class::Met::Class accessor.
        no strict 'refs';
        *{"$spec->{package}::my_class"} = sub { $spec->{class} };

    }
}

##############################################################################
# Private closures                                                           #
##############################################################################

{
    my %types = ( &ATTR => { label => 'Attribute',
                             class  => 'Class::Meta::Attribute' },
                  &METH => { label => 'Method',
                             class => 'Class::Meta::Method' },
                  &CTOR => { label => 'Constructor',
                             class => 'Class::Meta::Constructor' }
                );

    $add_memb = sub {
        my ($type, $spec) = @_;
        # Make sure that the name hasn't already been used.
        Carp::croak("Attribute '$spec->{name}' is not a valid attribute name "
                    . "-- only alphanumeric and '_' characters allowed")
          if $spec->{name} =~ /\W/;
        # Check to see if this member has been created already.
        Carp::croak("$types{$type}->{label} '$spec->{name}' already exists in "
                    . "class '$spec->{class}'")
          if exists $spec->{$type . 's'}{$spec->{name}};

        if ($type eq METH) {
            # Methods musn't conflict with constructors, either.
            Carp::croak("Construtor '$spec->{name}' already exists in class "
                        . "'$spec->{class}'")
              if exists $spec->{ctors}{$spec->{name}};
        } elsif ($type eq CTOR) {
            # Constructors musn't conflict with methods, either.
            Carp::croak("Method '$spec->{name}' already exists in class "
                        . "'$spec->{class}'")
              if exists $spec->{meths}{$spec->{name}};
        }

        # Create the member object.
        $spec->{class} = $spec->{class};
        my $memb = $spec->{$type. 's'}{$spec->{name}} =
          bless $spec, $types{$type}->{class};

        # Save the object if it needs accessors built. This will be cleaned
        # out when build() is called.
#       push @{ $spec->{'build_' . $type . '_ord'} }, $mem
#         unless $spec->{create} == NONE;

        # Just return the object if it's private.
        return $memb if $spec->{view} == PRIVATE;

        # Preserve the order in which the attribute is declared.
        # Assume at least protected here.
        push @{ $spec->{'prot_' . $type . '_ord'} }, $spec->{name};
        push @{ $spec->{prot_ord} }, [$type, $spec->{name}];
        if ($spec->{view} == PUBLIC) {
            # Save the position of the attribute from the public perspective.
            push @{ $spec->{$type . '_ord'} }, $spec->{name};
            push @{ $spec->{ord} }, [$type, $spec->{name}];
        }

        # Return the new attribute object.
        return $memb;
    };

    my %attr_defs = ( view => GETSET,
                      

                    );

    my $set_attr = sub {
        my ($type, $spec) = @_;
        $spec->{view} ||= $spec->{authz} || GETSET if $type ne METH;

    };
}

1;
__END__

=head1 TO DO

=over 4

=item *

Make it possible to subclass all of the member classes, as well as
Class::Meta::Class, of course.

=item *

Add localization using Locale::Maketext.

=item *

Create unified method for handling exceptions using exception objects. Allow
exceptions to somehow chain, so that all the exceptions for a given
transaction can be recorded. This will allow B<all> of the errors of data
validation for a given object to be recorded at once and show to the user at
once, so that they don't have to fix their problems piecemeal. No, this is not
a simple task. The problem is better described by Perrin here:

  http://mathforum.org/epigone/modperl/pahphucree/3D00F55C.5010103@elem.com

=back

=head1 AUTHOR

David Wheeler <david@wheeler.net>

=head1 SEE ALSO

L<Class::Contract|Class::Contract>

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2002-2003, David Wheeler. All Rights Reserved.

This module is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut
