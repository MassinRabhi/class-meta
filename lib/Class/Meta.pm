package Class::Meta;

# $Id: Meta.pm,v 1.6 2002/05/10 22:49:10 david Exp $

=head1 NAME

Class::Meta - Class Automation and Introspection

=head1 SYNOPSIS

  use Class::Meta;


=head1 DESCRIPTION



=cut

##############################################################################
# Dependencies                                                               #
##############################################################################
use strict;
use Carp ();
use Class::Meta::Type;
use Class::Meta::Class;
use Class::Meta::Property;
use Class::Meta::Method;
use Params::Validate ();

##############################################################################
# Constants                                                                  #
##############################################################################

# Visibility. These determine who can get metadata objects back from method
# calls.
use constant PRIVATE   => 0x00;
use constant PROTECTED => 0x01;
use constant PUBLIC    => 0x02;

# Authorization. These determine what kind of accessors (get, set, both, or
# none) are available for a given property or method.
use constant NONE      => 0x00;
use constant READ      => 0x01;
use constant WRITE     => 0x02;
use constant RDWR      => READ | WRITE;

# Method generation. These tell Class::Meta which accessors to create. Use
# NONE above for NONE. These will use the values in the auth argument by
# default. They're separate because sometimes an accessor needs to be build
# by hand, rather than custom-generated by Class::Meta, and the
# authorization needs to reflect that.
use constant GET       => 0x01;
use constant SET       => 0x02;
use constant GETSET    => GET | SET;

# Metadata types. Used internally for tracking the different types of
# Class::Meta objects.
use constant PROP      => 'prop';
use constant METH      => 'meth';
use constant CTOR      => 'ctor';

##############################################################################
# Package Globals                                                            #
##############################################################################
use vars qw($VERSION);
$VERSION = "0.01";

##############################################################################
# Function and Closure Prototypes                                            #
##############################################################################
my $add_memb;

##############################################################################
# Constructors                                                               #
##############################################################################
{
    my %classes;

    sub new {
	my ($pkg, $key, $class) = @_;
	# Class defaults to caller. Key defaults to class.
	$class ||= caller;
	$key ||= $class;

	# Make sure we haven't been here before.
	Carp::croak("Class '$class' already created")
	  if exists $classes{$class};

	# Set up the definition hash.
	my $def = { key => $key,
		    pkg => $class };

	# Record the class' inheritance.
	my @isa;
	foreach my $is ($class, eval '@' . $class . "::ISA") {
	    $def->{isa}{$is} = 1;
	    push @isa, $is;
	}
	$def->{isa_ord} = \@isa;

	# Instantiate a Class object.
	$def->{class} = Class::Meta::Class->new({ def => $classes{$class} });

	# Cache the definition.
	$classes{$class} = $def;

	# Return!
	return bless { pkg => $class }, ref $pkg || $pkg;
    }


##############################################################################
# Instance Methods                                                           #
##############################################################################
# Simple accessors.
    sub my_class { $classes{ $_[0]->{pkg} }->{class} }
    sub set_name { $classes{ $_[0]->{pkg} }->{class}{name} = $_[1] }
    sub set_desc { $classes{ $_[0]->{pkg} }->{class}{desc} = $_[1] }

##############################################################################
# add_prop()
    my $pvscalar = Params::Validate::SCALAR;
    my $chkname = { 'valid name' => sub { $_[0] !~ /\W/ } };

    # Set up Params::Validate spec for Property objects.
    my $prop_defs = { name  => { type => $pvscalar, callbacks => $chkname },
		      vis   => { type => $pvscalar, default => PUBLIC },
		      auth  => { type => $pvscalar, default => RDWR },
		      gen   => { type => $pvscalar, default => undef },
		      type  => { type => $pvscalar, default => 'string' },
		      label => { type => $pvscalar, default => '' },
		      desc  => { type => $pvscalar, default => '' },
		      req   => { type => $pvscalar, default => 0 },
		      def   => { default => undef }
		    };

    sub add_prop {
	my $self = shift;
	my %spec = Params::Validate::validate(@_, $prop_defs);
	$spec{vis} ||= $spec{auth}
	return $add_memb->(PROP, $classes{ $self->{pkg} }, \%spec);
    }

##############################################################################
# add_meth()
    # Set up Params::Validate spec for Method objects.
    my $meth_defs =  { name  => { type => $pvscalar, callbacks => $chkname },
		       vis   => { type => $pvscalar, default => PUBLIC },
		       label => { type => $pvscalar, default => '' },
		       desc  => { type => $pvscalar, default => '' }
		    };

    sub add_meth {
	my $self = shift;
	my %spec = Params::Validate::validate(@_, $meth_defs);
	return $add_memb->(METH, $classes{ $self->{pkg} }, \%spec);
    }

##############################################################################
# add_ctor()
    # Set up Params::Validate spec for Constructor objects.
    my $ctor_defs = { name  => { type => $pvscalar, callbacks => $chkname },
		       vis   => { type => $pvscalar, default => PUBLIC },
		       gen   => { type => $pvscalar, default => 0 },
		       label => { type => $pvscalar, default => '' },
		       desc  => { type => $pvscalar, default => '' }
		     };

    sub add_ctor {
	my $self = shift;
	my %spec = Params::Validate::validate(@_, $ctor_defs);
	return $add_memb->(CTOR, $classes{ $self->{pkg} }, \%spec);
    }

##############################################################################
# build()
    sub build {
	my $self = shift;
	my $def = $classes{ $self->{pkg} };
	no strict 'refs';

	# Build the property methods.
	foreach my $prop (@{$def->{build_prop_ord}}) {
	}

	# Build the constructors.
	foreach my $ctor (@{$def->{build_ctor_ord}}) {
	    # Create a constructor.
	    *{$def->{pkg} . '::' . $ctor->my_name } = sub {
		my $init = $_[1] || {};
		my $new = bless({}, ref $_[0] || $_[0]);

		foreach my $pobj (@{ $def->{props} }) {
		    my $p = $pobj->my_name;
		    if (exists $init->{$p}) {
			# Assign the value passed in.
			Carp::croak("Write access to property '$p' denied")
			    unless $pobj->my_vis > READ;
			$pobj->set($new, delete $init->{$p});
		    } else {
			# NOTE: Might have to construct a new object here.
			$new->{$p} = $pobj->my_def;
		    }
		}
		if (my @props = keys %$init) {
		    # Attempts to assign to non-existent properties fail.
		    my $c = $#props > 0 ? 'properties' : 'property';
		    local $" = "', '";
		    Carp::croak("No such $c '@props' in $def->{pkg} "
				. "objects");
		}
		return $new;
	    };
	}

    }
}

##############################################################################
# Private closures                                                           #
##############################################################################

{
    my %types = ( &PROP => { label => 'Property',
			     class  => 'Class::Meta::Property' },
		  &METH => { label => 'Method',
			     class => 'Class::Meta::Method' },
		  &CTOR => { label => 'Constructor',
			     class => 'Class::Meta::Constructor' }
		);

    $add_memb = sub {
	my ($type, $def, $spec) = @_;
	# Make sure that the name hasn't already been used.
	Carp::croak("Property '$p->{name}' is not a valid property name "
		    . "-- only alphanumeric and '_' characters allowed")
	  if $p->{name} =~ /\W/;
	# Check to see if this member has been created already.
	Carp::croak("$types{$type}->{label} '$spec->{name}' already exists in "
		    . "class '$def->{class}'")
	  if exists $def->{$type . 's'}{$spec->{name}};

	if ($type eq METH) {
	    # Methods musn't conflict with constructors, either.
	    Carp::croak("Construtor '$spec->{name}' already exists in class "
			. "'$def->{class}'")
	      if exists $def->{ctors}{$spec->{name}};
	} elsif ($type eq CTOR) {
	    # Constructors musn't conflict with methods, either.
	    Carp::croak("Method '$spec->{name}' already exists in class "
			. "'$def->{class}'")
	      if exists $def->{meths}{$spec->{name}};
	}

	# Create the member object.
	$spec->{class} = $def->{class};
	my $memb = $def->{$type. 's'}{$spec->{name}} =
	  bless $spec, $types{$type}->{class};

	# Save the object if it needs accessors built. This will be cleaned
	# out when build() is called.
	push @{ $def->{'build_' . $type . '_ord'} }, $mem
	  unless $spec->{gen} == NONE;

	# Just return the object if it's private.
	return $memb if $spec->{vis} == PRIVATE;

	# Preserve the order in which the property is declared.
	# Assume at least protected here.
	push @{ $def->{'prot_' . $type . '_ord'} }, $spec->{name};
	push @{ $def->{prot_ord} }, [$type, $spec->{name}];
	if ($spec->{vis} == PUBLIC) {
	    # Save the position of the property from the public perspective.
	    push @{ $def->{$type . '_ord'} }, $spec->{name};
	    push @{ $def->{ord} }, [$type, $spec->{name}];
	}

	# Return the new property object.
	return $memb;
    };

    my %prop_defs = ( vis => GETSET,
		      

		    );

    $set_prop = sub {
	my $spec = shift;
	$spec->{vis} ||= $spec->{auth} || GETSET if $type ne METH;

    };
}

1;
__END__

=head1 TO DO

=over 4

=item *

Make it possible to subclass all of the member classes, as well as
Class::Meta::Class, of course.

=item *

Add localization using Locale::Maketext.

=back

=head1 AUTHOR

David Wheeler <david@wheeler.net>

=head1 SEE ALSO

L<Class::Contract|Class::Contract>

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2002, David Wheeler. All Rights Reserved.

This module is free software; you can redistribute it and/or modify it under the
same terms as Perl itself.

=cut
